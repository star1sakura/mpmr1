下面给出可直接“照着实现”的**伪代码**（覆盖：数据还原→按赛制反推投票→一致性指标→不确定性区间）。其中赛制关键点：**第1–2季与第28–34季按排名合并**、**第3–27季按百分比合并**，且第28季起淘汰改为“先定倒数两名，再由评审二选一”；数据里**淘汰后周分数记为0**、未播出周为N/A、部分周无第4评审。

```pseudo
INPUT:
  df = read_csv("2026_MCM_Problem_C_Data.csv")   # 每行=一个参赛者(赛季内)
PARAMS:
  T_week = 1e7              # 每周总票数标尺(可改；只影响绝对量，不影响淘汰逻辑)
  beta, lambda, tau         # 先验/平滑/最大熵强度
  kappa                      # “排名→份额”映射温度
  eps = 1e-9                 # 防止log(0)
OUTPUT:
  p_hat[s][w][i]   # 估计投票份额
  V_hat[s][w][i]   # 估计投票数 = T_week * p_hat
  metrics, uncertainty

------------------------------------------------------------
# 0) 辅助：判断赛制
function rule_type(season s):
  if 3 <= s <= 27: return "PERCENT"        # 按百分比合并:contentReference[oaicite:4]{index=4}
  else:           return "RANK"            # 按排名合并:contentReference[oaicite:5]{index=5}

function has_judge_save(season s):
  return (s >= 28)                         # 倒数两名后评审二选一:contentReference[oaicite:6]{index=6}

------------------------------------------------------------
# 1) 预处理：把“每周状态”还原出来
# 1.1 解析淘汰周(从 results 字段提取 "Eliminated Week w")
function parse_elim_week(results_str):
  if results_str contains "Eliminated Week":
      return integer w
  else:
      return NONE   # 可能是冠军/亚军/季军等

# 1.2 计算每周评审总分 J[s][w][i]
# 注意：judge4 可能为 N/A；淘汰后周分数为 0；未播出周为 N/A:contentReference[oaicite:7]{index=7}
for each row r in df:
  s = r.season
  i = r.celebrity_name (or unique_id)
  elim_week[i] = parse_elim_week(r.results)
  for w in 1..Wmax:
     scores = []
     for j in 1..4:
        x = r["week"+w+"_judge"+j+"_score"]
        if x is not NA: scores.append(x)
     if scores all NA: J[s][w][i] = NA
     else:             J[s][w][i] = sum(scores)

# 1.3 按赛季-周构建“仍在赛”集合 A_sw 与“本周淘汰”集合 E_sw
for each season s:
  contestants = all i with df.season==s
  for each week w:
     A_sw = { i | J[s][w][i] is not NA AND J[s][w][i] > 0 }     # >0 表示仍在赛:contentReference[oaicite:8]{index=8}
     E_sw = { i | elim_week[i] == w }                           # 可能为空/多人:contentReference[oaicite:9]{index=9}
     store (A_sw, E_sw)

------------------------------------------------------------
# 2) 核心：逐周估计投票份额 p_hat
# 思路：先给一个“先验份额” p_tilde，然后投影到满足节目淘汰规则的可行域内
function softmax(vec z):
  return exp(z)/sum(exp(z))

function zscore(vec x):
  return (x - mean(x)) / (std(x) + eps)

# 2.1 百分比合并周：凸优化(可用任意凸求解器)
# 约束来自：评审百分比=J_i/sumJ，投票百分比=p_i，合并=q_i+p_i；淘汰者合并最低:contentReference[oaicite:10]{index=10}
function solve_week_PERCENT(s, w, A_sw, E_sw, prev_p):
  n = |A_sw|
  idx = list(A_sw)

  # judge share q
  Jvec = [ J[s][w][i] for i in idx ]
  q = Jvec / sum(Jvec)

  # prior p_tilde：用“上一周份额 + 本周评审表现”构造（隐含人气与表现）
  zJ = zscore(Jvec)
  logit = beta * zJ + lambda * log(max(prev_p, eps))   # prev_p对齐idx
  p_tilde = softmax(logit)

  # 如果本周无淘汰：直接平滑返回（或只做最大熵修正）
  if E_sw is empty:
     p = argmin_{p in simplex}  ||p - p_tilde||^2 - tau * sum(log(p))
     return p

  # 有淘汰：构造线性淘汰约束
  # - 若无 judge-save(第3-27季)：淘汰集合必须是“合并最低的 k 个”
  # - 若有多人淘汰：用“淘汰者不高于任何幸存者”即可(不要求淘汰者之间排序)
  k = |E_sw|
  survivors = A_sw \ E_sw

  # 决策变量 p (n维), 约束：p>=0, sum(p)=1
  # 目标：||p - p_tilde||^2 + lambda2*||p-prev_p||^2 - tau*sum(log(p))
  # 其中 prev_p 是上一周对齐到本周参赛者后的份额（新进/回归者可设均匀）
  if has_judge_save(s) == FALSE:
     constraints:
       for each e in E_sw:
         for each j in survivors:
            (q[e] + p[e]) <= (q[j] + p[j])
     p = solve_convex_minimization(objective, constraints)
     return p

  else:
     # 第28季起：只需要确保被淘汰者属于“倒数两名”(Bottom-2):contentReference[oaicite:11]{index=11}
     # 做法：枚举另一名 bottom2 候选 b，找最优可行解
     best_obj = +INF; best_p = NONE
     for each eliminated e in E_sw:
       for each b in (A_sw \ {e}):
         constraints:
           for each j in (A_sw \ {e,b}):
             (q[e] + p[e]) <= (q[j] + p[j])
             (q[b] + p[b]) <= (q[j] + p[j])
         p_candidate = solve_convex_minimization(objective, constraints)
         if objective(p_candidate) < best_obj:
            best_obj = objective(p_candidate); best_p = p_candidate
     return best_p

# 2.2 排名合并周：先求“投票排名”，再映射成连续份额
# 赛题也明确：满足结果的投票有多组可能:contentReference[oaicite:12]{index=12}
function solve_week_RANK(s, w, A_sw, E_sw, prev_p):
  idx = list(A_sw)
  n = |idx|
  Jvec = [ J[s][w][i] for i in idx ]

  rJ = rank_descending(Jvec)          # 1最好，n最差
  r0 = rank_descending(prev_p[idx])   # 以上一周份额当投票先验排名(也可用softmax(beta*zJ))

  # 用 ILP/CP-SAT 求一个“最接近先验”的投票排名 rV
  # 变量 x[i,r]∈{0,1}: 参赛者i获得投票排名r
  # 约束：每个i恰好一个r；每个r恰好分给一个i
  # 目标：min Σ_i Σ_r x[i,r] * |r - r0[i]|
  # 额外约束：
  #   - 若无 judge-save(第1-2季)：淘汰者 ranksum 最大
  #   - 若有 judge-save(第28-34季)：淘汰者 ranksum 属于最大两名
  # ranksum_i = rJ[i] + rV[i]

  if E_sw is empty:
     rV = solve_assignment_min_cost(r0)         # 仅贴近先验
  else if has_judge_save(s) == FALSE:
     rV = solve_ILP(
            assignment_constraints,
            argmax_constraint_for_eliminated(E_sw, rJ, rV) )
  else:
     # bottom-2：枚举与被淘汰者同处bottom2的另一人 b
     best_cost = +INF; best_rV = NONE
     for each eliminated e in E_sw:
       for each b in (A_sw \ {e}):
         rV_candidate = solve_ILP(
            assignment_constraints,
            bottom2_constraint({e,b}, rJ, rV) )
         cost = Σ_i |rV_candidate[i] - r0[i]|
         if cost < best_cost:
            best_cost = cost; best_rV = rV_candidate
     rV = best_rV

  # “排名→份额”映射：p ∝ exp(-kappa * rV)
  p = normalize( exp( -kappa * rV ) )
  return p

------------------------------------------------------------
# 3) 主循环：逐季逐周生成 p_hat 与 V_hat
for each season s:
  prev_p = uniform over A_s1
  for each week w:
     (A_sw, E_sw) = stored
     if A_sw is empty: continue   # 未播出周(N/A):contentReference[oaicite:13]{index=13}

     if rule_type(s) == "PERCENT":
        p = solve_week_PERCENT(s, w, A_sw, E_sw, prev_p)
     else:
        p = solve_week_RANK(s, w, A_sw, E_sw, prev_p)

     p_hat[s][w][A_sw] = p
     V_hat[s][w][A_sw] = T_week * p
     prev_p = p

------------------------------------------------------------
# 4) 一致性指标（复现淘汰/Bottom-2）
function predict_elimination(s,w,A_sw,p):
  if rule_type(s) == "PERCENT":
     q = J / sum(J); C = q + p
     if has_judge_save(s) == FALSE:
        return argmin_i C[i]                     # 合并最低淘汰:contentReference[oaicite:14]{index=14}
     else:
        return bottom2(C)                        # 只预测倒数两名；淘汰由评审决定:contentReference[oaicite:15]{index=15}
  else:  # RANK
     rJ = rank_desc(J); rV = rank_desc(p)
     ranksum = rJ + rV
     if has_judge_save(s) == FALSE:
        return argmax_i ranksum
     else:
        return bottom2(ranksum)

# EMR：淘汰命中率（第28+也可按“淘汰者是否在预测bottom2”算B2CR）
EMR = 0; denom = 0
B2CR = 0; denom2 = 0
for each season-week with A_sw not empty:
  if true E_sw is empty: continue
  pred = predict_elimination(...)
  if has_judge_save(s) == FALSE:
     denom += 1
     if pred == E_sw: EMR += 1
  else:
     denom2 += 1
     if (true eliminated) in pred.bottom2: B2CR += 1
EMR /= denom
B2CR /= denom2

------------------------------------------------------------
# 5) 不确定性（可行域宽度）
# 5.1 百分比合并：可行域是线性不等式 + 单纯形 ⇒ 对每个p_i做LP求上下界
function uncertainty_PERCENT(s,w,A_sw,E_sw):
  build linear constraints same as solve_week_PERCENT (不含目标)
  for each i in A_sw:
     pmin[i] = solve_LP( min p[i] , constraints )
     pmax[i] = solve_LP( max p[i] , constraints )
     U[i] = pmax[i] - pmin[i]
  return U

# 5.2 排名合并：可行域非凸(由排列决定) ⇒ 用采样/多解ILP近似区间
function uncertainty_RANK(s,w,A_sw,E_sw):
  samples = []
  for t in 1..K:
     rV_t = solve_ILP_with_random_tie_break(...)   # 多次求不同可行投票排名
     p_t = normalize(exp(-kappa*rV_t))
     samples.append(p_t)
  return quantile_width(samples, 5%, 95%)

------------------------------------------------------------
RETURN p_hat, V_hat, EMR, B2CR, uncertainty
```

